<html lang="en">
<head>
  <script>
    /**
     * Component Engine
     *
     * Okay, so I'm gonna implement another basic pattern. I'm gonna make an engine
     * where all objects have components, each component being able to update itself
     * during the loop. Along with that, I'm gonna try and make everything in separate
     * classes, and have the main game loop be its own class as well. We'll see how that
     * goes.
     *
     * Notes:
     *  - A downside of doing this in javascript is that I feel that all my properties
     *    and methods are very exposed. 
     *
     * @author Marc Khoury (khoury.marc@gmail.com)
     * @date November 23rd 2013
     * 
     */
  </script>
  <meta charset="utf-8">

  <title>Component Engine - Koganei's Game Design from a Beginner</title>
  <meta name="description" content="A second test of a game engine, but with components in objects">
  <meta name="author" content="Marc Khoury">

  <style>
  html, body {
    
    margin: 0 auto;
    padding: 0;
    background: #333;
  }
    #world-container {
      position: relative; 
      width: 960px;
      height: 640px;

      box-shadow: 5px 5px 5px rgba(0,0,0,0.25);

    }
    #world {
      position: absolute;
        top: 0;
        right: 0;
        left: 0;
        bottom: 0;
        /* clips to bottom */
        background: linear-gradient(to top, #154277 0%,#576e71 30%,#e1c45e 80%,#b26339 140%);
      
      
      z-index: 1;
    }
    #map {
      background: -moz-radial-gradient(50% 50%, farthest-side, #5389CC, #073D7F);
      background: -webkit-gradient(radial, 50% 50%, 0, 50% 50%, 350, from(#5389CC), to(#073D7F));
    }

    #debug {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 300px;

      background: #555;
      box-shadow: inset 2px 0 5px rgba(0,0,0,0.25);
      z-index: 2;

      padding: 20px;
      box-sizing: border-box;
    }

    .tile {
      position: absolute;
      /*  float: left; */
      width: 1em;
      height: 1em;
      background: #deb074;
      /*border: 1px solid rgba(0, 0, 0, 0.1);*/
      -webkit-box-sizing: border-box;
          box-sizing: border-box;

      background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABgCAYAAADy8ayIAAAACXBIWXMAAJnKAACZygHjkaQiAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAI69JREFUeNrsXc9vG9ed/5AiRVESLTKWRc3WtigvrASxIRdukzRoUMgoFtiih73soYfusZfFItg/oXst9rDI1Ye9Fb0W2KJbYIv44MKN1Qo2EQc1lVhUqGREWTJFURIpiRL3MPw+vnl8M/PmJylbDzBMzfA7853H+f7+Ffv5r/7QwTled2b+y/E7W3ocM9pZYN/j19PftTE/P246Vqu12edcLsGO7e4eI5sdNX13d/d4oPBzPzwb6P4Nei3/NovFO7dMx15Wt9nnK/lpdkzfrEKbzZu+q29WfcGXkxuxQT5/YhA3Tc3N4mh9M7L7lfQ0gKbty7mlx5W+Jy6RoGq1NnK5BDK5twAAX7/YYufm58extnaIbHa09x3u/EDgsTnQ/Yt6iUxKJMiX1W1cyU/j8vRlAMDfnj1n5xbv3ELx6TNos3nTd/zAl0sbeO0YQGpuFgAsifxofdPxO0GuBa3p+FJ4Xbu7x31/53IJNGqvAADXb8wAABq1V6jV2oz46Nig4S9pg92/KDUK2fX0zWrf31fy09jZ3gEAvHPrbQDAzvYOXla3GfHSMb/wg17xoAmfpDtP2Km5WRTu3Ubh3m0T4UdB/PRylvS09EXtSS7jRbf6np0GkMslGKGJGkGj9ooRYy6X6CPYQcMPev+sGEmYTIW/NhEkEaqoEexs7zBCvZKf7iN4v/CDXoFqACJB88ygLDCEqKQ/AFS2FpEeAUr6qlRFTY/cBFBESU+zz25Xo/ZKam/TMVK9s9lRZqPzNvmg4O+86/wK6CvHyOAYJUxJ9y+j1wFtFCU9zT4HIaWDNiVmtDNLrWJne0dqr9MxUt212Tyz8Xmb3is8rr0GGgAv2a3sfNIOeOkvwgQp8cXVPF1FeuSmSUKR9EpoS10mcRMJbanvO3bSSCZRc7kEstlRJpVFSU1Emc2ODhxedf8a2hQyel26f/Pz4waT0OuYnx93tX8igco+B80E7EwAktTabJ5JdVHSE1Frs3nf8K+FBlD+9PM+yS5Kd/qbZwz8saA0AuLyvAMrc3UJGSwZ0l4HKlsQJL7BIDJXf2HSCHj1FmhKXyAZEZEjjuxu3lPPq+NWK1r4Y+f9wzEWx06A+XGsrdWh6wDuchJ/fhwNbcr4DqcRqOyfE4GG7UeQESE58shu5z39vDpvtdzAl1+dIydgam4W2o1p6C+2pcRqRcCNjftY0JrQRz62NBOCjBbQS8wTOHtgzWAEFR1Ij/T+JuKn75Q2VhkzuDZTtH2J+LAb74izYxJu4BvaFFq5JsZqiVDub7d/Gb1ugidGsrZyiAyOmUlxDW3UmmLkwGAG2t3RwAjbiaD586qaBx+24x15dkyCh/MKf658AESMZQup3di4byIikfhntDNA/wT6yMeWmoHIXMhMcMsE+B+eCFy8Dh23YjjEOHrMQB7espPERpjtVR+h8vY5wRdbSSZBefhiq8H2bwttNF/I4b3e32n/+BwDVXiDCuoMvqgn4Tc8SIRtZ8d78SPYSXIxzCcSenUsbatVWMGL/oFBrpHFf/iXX6oSP30+re+zfzyRZzqfYT/+ARob91GY+BP24x+gMPEn9iNMZDqI7z1GpvMZ9G+LSF36nun6u+UtnNb3kZqbRSI7ye5B95St2Yk/W3qt0yM3Ec8UAMAEX7h3G81OvO+a/N/xTIHBjhw0sHeQx4tvG/haH8UYTjGRMfKnjl6O9OGUTsdRq7URx5GJeK7fmOkei3WldJIR/4LWRDt9hkQrjtVYClNXjnFWO8LUlWPT/h0nY8hoI1hrpZFPyF9uN/dPXTm13L+MXmc42uEvuz8Qg6alAACHlX3s66f4cj/Tt3+q62A/xv7ZEfVEpoOD/RgmMh1MZDrY0uMMTnbP093r/deYHMfL6jZi8ZiJeKtjaRwkkuyfJa6JJGL1vT74d269jVg8hngsDn2zivzsDL5tbv7H0GsAvOQUHXtH65s9CQ+gtNKT+KWV+9A0KxuvCd3CdPDjCyAJQQ490Xwpf/o581nIzllpC9rpJ54kGElNPjYvSk5+/x7qSfb3Qz2JBbQt9w+1RCD3l+0fOfTcwsvun82OIn0DuKMdhOLBl2kJQfkUSGrz0j6hLaGtP5CaluJxgudzA4ZB8nvyAZCkB8Ds+cbGfdy5e+bLqaOdfsI57H7Rx2BUGYJJel1d6mMqZYkjkj9XuHcb5U8/N5gBd97pGe2iA3xorpJO95JqamDS/yPt2Nf+tXJt9txkRsjuz3923D8c98E4wVs9v/GMB75f1igdiOTdF9V8InSZCSmD50OD/OdhWY4mQOHebeyWjXRSUud5Vf5ypm1SrcZwyn6I69qJraoW33sM/dsiLmfamNHOcF07YcdSl77nqP6LJgCpfWM4xX78AxMjoWvY+RTILNgtb5lgRg4aSHS2pCqkzAQwCOAErdYpU5M3N1soLHTY/h0nY2inz3ztX73dwRe7KdP+0bHU/lHf/YEYWq0zTpWHyQQw7Z9+qgRvzQB6z39Y2Uc8k3Ct9kexZCYAAMRjcabOy/xGZKaSqUrrbL+MhLaETmIXjY1vkJ81QrFffbWGeCyOw4NDZgoAGH4TQH+xHRq3NdS1A8l1e+aBKI3dLpLqKuaF1Tk7R6DMA8973um86IkPe/+azf77U/4/qfJ2S4a/DF7l+bPZ0aGtE5B58LXZfJ/KL5qKdtEsMgPihQK7Pp//PwwpwMoMgPfEl/R03wsXphpmx4CcTQAzvNtogvhdI4lIzgREwqAwHBXkUDw+yv2T3Z8+q+zfYu5EGV7l+XfX6paZhINeVoQp2vpiRquVsOBhRLV/mIgfUMwE5Inh4cpEqAht6XFUthZdOwQpbl3ZWjT5EcSkI5Uly1BMaEtIj9xEZWsRD1cmGLGQxOMdZHx6Lk8UUe2fvnIsvb8orfm/af/0lWNcazaV4VWfHzByAvSVY9P+DXqRrS5z0PHvgVPWKp/ZmtCWmNbAh/5EbWMYfAFxVQIgKchLijBe3pKexrWZIhob95U2npecC1oTzdNVaKefMHjVZ7P6Mfv8BKerJq+9nfebJ5hsdtTIkItg/7S7oyi2kn33JyIWceP3r6FNIX0DruFVnh8wkppU9m/QK99qYvLBf5tUejeLYMiUoLThl9Vt9m8oTQBZDj/97ZQRF4yXt2lpgjip8TJ4N+q/031kz++mH4B2d9RXKMzt/l2/MeOqH4AneBf9CMJ+fi/LqR8Anj1HdSyNo26UyCoLlvdXEfHnW8Zevuz+P/T9APgXX3xYr3Fwby8xADRR6mYX0saqMwEzPA/nNe3Y6vlV6/FfYivy/fuTDvzQZT8At/DD9vxeTQD+bz5mz0v0L3/9wDb8xzub862miZGcq34AqblZk6czKuIPwhFoScA3ppX9HCIjsHt+lXr8Qb78fvsBBNGPwO3z5//601B9JKIGYFfPfyU/zSQ5Tx+Fe7f7ri07dq76ATCC50JvURM//UBUw+/WgSeD55mITNKLdQj8d1Sf36oeP30DA9k/quEHFe8o9gNwC+/Uj8Dt8xPx5//6U1S/97tQiV8kVLt6fnLuGer9EsqCaSpqAGIi0LntB8B7vd3Udvv5gaiSTKZu2TEDO3g+GsD3L2BFTl2NR2QQTs/vVI/Pe72j3r/Fu1elktqqH4AX+CCff0uP48Xuc0x9+E0EJpLcBCCiFev5ZQ5k/p0ScwDOSz8AUyYgZb/xhTLxTAEjBw1U9/aws5/E5UzbsrDC76JCjsuZNqp7e6xYiMdNXGImoBW8iWi5oiORoYj3cHr+o5eJbvFLvyPsuNUEEENn+xA6JiPdPx2TyLUPUKu1sbnZYoU5x111Np2OI52O92UCuoUHYoE9/8F+DKMvc9j88hi11g5207uB7pXsOp36HCYmx6WOwOZhk2kDsWwWJxuGhD/bL7N/8UwBbf0B+5u3/wn+q6/WcOPvC4Zn5dDYv4nJcUxMjg9nJqAoCcP2/js58WQ4uYHn+xGoahP8cgr9OdXjR+n95p+/qKdxDW1X/QBk8H77EaiG/oyS5xdSfMIwCXiClzkCTZGCVtOyLoD3+FvCD+lKqDjCok7jtFITvaQFO/Uj4L/n2M9AslTq8YOoh/e6fzx+rur5yQTqFjA59SNQ6WeggrOs6i9Mv4CbfgDgbPd4odCXHyBe6zz0A5C+AaKkNTLgqKkmQk3kEOv5TZzZRTSAj2mbmkPo/ZWHrMrx1GAQvMbg5VlzuUSX2AzveUY32miVtKlI94/adRHxX78x05eu63b/thBHGkZufw4njPgXtCZaAMZqCVTSaaRzTaD2CgtaW+lZnUp4pz78BvVH34mEKK7kp6VZe+/cept59PVyGfFCgUl+npiV4AUtYWgYgNj842h901c9vBcVVqznd1sWbOf0kfUjcNPPwO0Kqh7e7f4FVc9vt3/Uj8BNPwMv68Xuc+D3APAcEy6ZYVD9AKT1/F1b3zP8sJkAVozASz28b+kl1PMH4fG1Uv399jOQOhpDqId3tX8+6/lVnz2IfgZO6+DdF66v5TfaolLPb0fI56UfQFzmACR7mzcBoijeoG4u/CSawr3bocwPmNHOoJ1+0jf1hpdmH931R7TEBDJ6fSD7x4fo+Dx+PpTn516tXDvU/XPLRMQwo1/mw4cI+Tx+PpQXJvxANQDe3nZqjBnWoozEMAnG7xrWenjVev5B71+Q9/LSCkwWAQB6nnunen6/8EPLAMSwm109fDgmwGA2xMuzDUs9vNd6/mFjqlEvkTDJQSfm8dPnoOGHjgHInG4JbYkN1Sjpq4F7svk+/mT/RzlB2I+ab+VgE4mNjwaEtX8ZvY5rWQBjCdP9xR6BpB1cwpu9xOIfXjXniVW06Um6+4VHcrDPH/v5r/7QcVLDVYtjrLyuqt7YhysT0qagoa7l/zT1vhfVell+u8gA3MJb5ccHsX+LYyeu8J/74ZkSc1G5vxev+9Otf8fFGiInoB0jcCJ+q8mwqhNjP7p7wDoE82ZIFLYyT7yU8379xoypscX8/LhJkl6/MeMa3o74g9i/Vs4d/ipL5f52+F+s4V1KPQFVbU+rZTdf3mqUE0l/v01BVVR4O5X+ekD18ASfzkWzf6r4X1LIc7C7vwr+g1pOo+yGfUWBf1wVERkCFHaxmw/vNF9eJm1MNtqLcGOmKvXsfuvhrRJwotg/v/0AnO7vhH8URCJOp6ZjYpWn7DvDQOSDxF8pGMxLYQpn0ecFrcmm6fbSd4smeKrNl0UR+OsBvb6DXpp5+llW9ex0zGs9vAhfafXvH03TZem7mpmJUG2+LIog7l9Gr6PWLdNVwV/sByBb648vIQWgBEAWxUhVkkCX+OlzFIRD70dZMlmqbDNtSjbnMmoNYVjwV2IAfCye6gKMzwZRZ64umabtynIGmqerfaFESvkl5gHAlAEYxQ8jy4mnv/nceTGOTuq0W/hdGq8NMKJenE+wabtWwzQb2hQyujmUSCm/xDwAYHG+h4sK/sCZkiPv6NoJUpWkiQmQ9H/vzi0UHz9DCkbfu2X9iek7QDDhQavx81ZNO8UW3ZRaztfuJ7SlyIh/GPF3nQ4mNulI6z0CJw8+ETULTV1dQgZL7PsGAymyc8Q8orb/ZSo778gjQuE9/Sr59HbwYsRgbc0o2GloU6yajoia7R+OjXPz41gjBnLXIPprWa57DwB08//V8TebBDzRkoaRAvDeW98F3jI626xXksD7ez2J/5bBIN5767smjYA3D8TCIjdL7E8pIxjZbD76TIRk191XnHYdpPAZZvxtw4CywiAV3wAA1pZbHNIpezi3vodAGcDqJ1KtYJ6rorMjeFlefRDwjW7lYEavS0t319YOLRmYm/tfevfY1qufqiSlpavFp88M81BS665vVnF07YQxg7n39ywJ3ykMKE52kklEOja9b5ie25OLllJUJmH5d1C8XxDEr4o/VRY6DSINEn9lDYAcEfwUXZE4eU5Htrw4T43gnIYrRmWXqdTzi8Qqq4cPHL47Q4DXGNzW86vc38mrv3jnFvvspp5dr1QZPG8SBEk8IuEzk6dWxPbkonF8tWh5/W3dfJ2EtoTyp58H5n1XxZ8In5ULd0eR51tNYO33ltevdonfD/62w0HF4Zw0OLNw7zZrG0bnU3Oz2HnywtRKLJ4p9BE0P6RTHKzIH4/KLssdLvcdS6fjqNXapgGYVERjHIt1bX95GlcQ8ECMteEK8/58SzDR65+qJNlwS6v59rI1MTmOeCzO2mDtlHZQ/yaFtcMRfK2PYgynrD1X9eAHlr8NvWPUcotecmq/dTP5BeJ7OnK5BGb+bpqZN+l0HPE9nT1vOh03DTWldmbxPR37xz2HJbX4ovecfzedhtR6wf/21ARi9T1cyU/jeuEayxycmBxHrL7H9ntictw0VJTaicXqe2i0vvGFv6c8ANmwTatOuxTKO7LwaorcatjitX7r6c8bPPkAUpUkFu/c8l3PTr3wR6+v+nIEinbw9H4R4DQoWY0DXwPBPz/vp9k+gaWdLTaV9WMeiNfPt5rA1ITtjAC+hkCcVUDlxdX6gS/8PdeEik4HUW2XhTJkMCoDFwexxNx5t/X05xHeJP3RX8Pupp6dz31ffvUEH3kgfpkwuJn8ItDnn943zAWypVNzszj482+kfqryp5+7YgIy/G9PTbjeP7v9z3d7FXrF3zMDkD0cn7rrxmE4rIsP8fEJNHx47XWC57v9rFeSprZVfG0739rK6SW+kp9GqpLElqZeJyAbtd3WH2B6v4hawM+fyyWYz8CQoP0OOt7RppKYZoV/vtXEy1bT9f7Z7f+V/DTzGXjBPxE00VgR+bASv0o9P/0tq6c/7/BWK8h6eG02j5J+ouwIFGfsJbQlZFc/CXX/yJHIOwidnHpu8L+89vtQ+gnQeXF6UVUSOQjUBHidlko9v109/XmHl5kA7wVcD68/rVpmEtr5mETveRT7Z3AGQyvgveyqael2+IfRT0DaaKSrFTjh/8YzANV6fqt6+vMOf4kjfvL8F7rSJ8h6eMDICVivJFG6dmLbD0FmLka1f6JWkZqbZWq1qhYrwz+sfgKyYaa8VuGEf6KxcT/2JjOAVHu6kxq/ZTo20tjGXgOmDb88bWz2SKKX+DKSAI7bVZxneOA5Z/83UQIwqq1iWd9A4eSqaYyVm8GWYuNMgj9yIH6zL6knvUiFV21oKiZAWY0xs1ok/Q/+/BsktCXXzj8Rf1LhVRuCWu2f6iLp74T/G68BOM2H/9uz5+ycbL677Ic7T/D7eC44AZsmZ1OQ97fLCLRbCW3JsMlrRZMEz+TeAl5s9RE+r/5/zZ2fnx9nRVHsOxJ4yiR06/yzw7+qPwA4T77BlMP5/SmTUAX/N54BOM2HpwGPVvPdzzt8atI6EvC/pT/iH2/9OJD7v2j8j6cogCiVeSbgpR+DSj8HTJo96W4jWFbfr46lTUwgrN8/Xigo4//Gt29xmg/vNN/9vMM7rSDu74b4yYvOO8/45B+//RjcwNsV33jBP99qRvr7q+A/8s4H777RDCB7dumXE5PjaB42WYolTXSNx+Jscmzx6TPEY3FkJidxeHCIw4NDfPXVGjKTkzjP8N95p9UXCTjYj2H98SUk9kZYuq/X+7cvP7UlflkqMKXQUvosACQ2/oKxsRGMjY2g1TpDq3WGzc0WxsZGkE7HcdxqshRfmmjMTy42iqdiSvDxPR2Ho3nmQe+cuuvhL8P/rFxGZnIykt8/Vt/DQSKphP8bzwCa3zZ/Kea0Uy77O7feZuOc47E4y9mOxWM4PDhEZnJSmhN/nuAvXd2RhgETeyO49+Mf+b7/k4ebWDscwRhOcbAf6xv3LWMAlLN+tl9mufNvxbdZzn8cR2i1zjA2NiKtiaBaius3Ztg4cyDmCp7qBHg1WrUWQIb/7Fgq0t+f6gSc8L9wAkrKWckRQ3aXvlllVXEq+fDnC97sBNzS40ZrL87u9HN/bTYPvUI5AEbbMLvuwU72tt9+DKrwvCMQAAr3/k0pZd0J/6h+f94RaId/VAyg0+0XN5QhR6X58AOEP7p2gnrqEaaOPgzl/lZOwGX9CQq46vv+KqE/3n4uS7rlbE8uIocvLAlW5gjk7Xy7Jc0mFByBqlEAK/yrY2lcifD9ER2BUUQBOgBiVsTfDTF1ho0JuJkPL6uHDwp++dUT1lGHh19+9YQRz5b+CMdf3wz0/k6rnNxQur8K/l7CZ22u5j3KfgzbHAFP/OBnnlLZRfzDfH/6fCuK+AfFADrd1tFE4Ezi8z8+MQGyMy0YxlAwBT/z3d3CE5HUYUjZcnIDo6lVYPtDiPu3hVXMXQdK+gmuYDoU/LnfyqQVWN1fFX+VxUsqsRCIL+KR9WKk1UsYMhO/G3jUiti9+THa+gNXxG+Ff14oAgry/ZEKteo2duZ/4oh/IAyA/5FLek/il3R07FRMsYX1MJsHfurhneD5/Xu40pOYxmfr/eP6fYSGv0i8svu7wd9piTMp+Vz2qPsp8CW2qkzADv+w3h8/+LvNA+gsaM3OgtbkCbtjx+FVuD93zc6wED6NcyY1i+fIqvXcIvzyqyeopx6hnnrEvrf86gn87h9dc/nVk8DwV713EPi7Xar9AMgZKKYQq6YTExFRXD8sn1MY758q/q40ALM61+w4fcduPjznE2B/z2gH2NLjnWExD4Kqh6fPC+/39mYLq6hjtU9Cutm/Lf1Rd7YAv3+Pug09/NfzOzGHLf2RZ/ydpKiMoGlF1U+BJLjbNGAZ/kG8P15+Pyf8E35eAL+LXlqZ7RmVeRDlfHhgL7L9Oz65qoS/3/uHuXj1Ocp+CtnsqKmzsKjWe8E/iPdHFV6bzZs6C9vh74oBlPR03wsX9UsRltMvivnwUe7foObTBzUAxLLdfFT9AGD24ruZUWGHf2T9ABTxd10L8HBlItQXaEuPQ185joz4iePyDhaNq4fnfxSZZ9YNfFT7t/74kjL+w7hIYvHVbGTTi74Akvi8g48f18YzBVV4npDJjvaLfxDvjyq8G/xj//TxPys/WEavdxralOe4rsrLS/PyVP0AH9096KhcN6z59su/zZp654uExTdyVK2HD2r/+Hp+un9/scmzvmlFPKHI5h2KKrMv+JsfS5+F6tf5QiCxwadVezOr805zEfjz7avfN0lStyaAiH++1exr8Glljlmdd8rj4M9TIpAT/q5MAO3uKO5oB6FxfrEePahFAzTtiK43xsodcbrpJ+C1Ht7r/qnU8z97umpJPIC3eno38LtWmpmN40oW53c675QH0Hd+4y8mJuDWD2CHv1NjEC95AH3ny2UTE7DCX5kBLGjNThT2vZAn0EEA0YAw59uHUQ8f1P6p1POHUU/vBt4il8n0olo1BFFZTnkAdue3AccJVnZmAI+/rCGIGye1VR6A3fmqAv7xYSL+sGxi0gLCmG8fRj18kMupnjzMenoVeCdnmtVsPJlNLzvvlAfgdJ7u7SUKYIe/zKaXnXfKA3A674R/YtiIn4iPJt7SkExfjr7utfjR2oJvg43Yps9eCE1mb/udiON1/9YfX0IKAAxNnKn+2mzeZCvOTPcIVWav0zFS3bPZ0T5b2g88bASi6LkWOwLZpfOK553yAPjzfAjQChcl4SDAiB2BnNKx3eQB8Of5EKAT/gkV4il1HX/9amZ40rpL/DEv15Dh19CmkNHrJibApL+WjmGl3qF7NnR0VOfby35E+vudW2/j0z9WWRfcKPcvBeDej3/EXhQxjkzmwM72dh8R0d88oYhxdFLnZUToCt5Gepom2HQlKTEBMc4vErLbPAAx9i9O3nU7EswKf2ICYpxfJGS3eQBi7F8Vf0cG0NCmYhm93jEIx7me26/92qtHn/J1DZMDUDMqELtMoKPrAO72JH5DmyJNI8ZrBCrz7Z36Cbithw9u/9Tq+U/bo5ZedD/19KrwuwrPJVbVUeSAioRkeQCiFKfBHyLxy6Q9fz9+4rXXJeK/M/8Thj9FB8Q8AFGK0+APkfhl0t4N/kphwEH4ADjis9UCrMKABN8l8L5rZPR6hxicxaU7xAy0u6OWBLvx2dtSrYAI7mV1O3IzgH/+Qjcj0ErV3PzmkVR1JoIV22vLHGxe4QFgbfpfLZ/Bbry2jLj5RW29ebi+6T9d4he/xx/zM9JOFX9xqg+p8SJefdN/usTvB38ll6qX8FgQqmwQ8FYE7mReZPQ6+x5vEohLpZ57Wd8Y2P7JPMZ8HNlLPb2drQwA0yjawlvF4cUlDrMUPdp8sxDZEglOVPEhNO0Ur+93nqUq/jIpLsNfVPGDwF+JAWT0OnQdKGk9MyASP0BXPY8SXsYg3D6/6JXlJ+JEuX+pSpI5Ad3Uk1vF0a0ITSZ9USvCaz2+SERWA2dlkk88Z0VMVmO06V6y+3llAsOMf0KVGBa0ZifMJCDRjrVS3cOGD/r5ydkWlRlAz5+qJLF455bvfgAktWUOMpWX2U89vuxFltm0drFukoJO8XArIg1iDTP+qr9EJD4AXnqR4y5K+CCfn5/ltvzqCT6KeP9S6J8pL5svb7XImy5KfXoRnV5IcRYfOQbtfAeqEtXq5ae6d8rCO1rfZARBhJSamzXVxxMxRjW9etjwVzYBtvTR0CWY325BYXUb8vr8pGanKklsafFI92+94q8fgKyRpqqqmdCW0IaRTuu3Ht+NhLWL09N3jtY3Xcfzw16DxF/ZBLBzhL3uy+75VeK42mweJf0kUkegahxZpR6e9yhrN6ZR/vTzPqLnHU6sF97V76NWKzKGYlfAc7EGs5SNMTGJJnQTYADwXp9fpZ5bf0q5ANHs33su6smd6uF5KeQkfUQYUe2/IP7hWsrxtm5CEPSVYzxcmfAdqpO9vCU9Tb0AYlHDe31+1XpuoBsNeHwp1P1bf3yJxf5V6slV6uHFz1YqKn0noS0xrYEP/cnq8S/WOdEAiAgA68Qgqww3lcy3bhdhz5773nz7KSxozdD6Cqr2Q7Ca767N5jGqrSKs/SPPv9/58tP7ReD/ijiYXERbf4DU3M9c7ZM40IPShvv2c+N+7IIMzwkDcCJ+q4Qh1USij+6ypqC+mEBodrWkH4KbfgCLd26hnnqEcPfvEa7kP1SeL+/UDwAvitieXMTR+qZjWikVnIiZd7XueVk/gIreuKDC88QA7GxPG6ZhC8s65QagFofRT8CO8bmd7z56PZr9U50v71TPz0v0L3/9wDb8x4e4+Bx9MjGk/QCQvKDC8+ADsHr5nOrpnerxxTWMw0LsaiHcznePev/89gPI5RJ9OfSpuVkU7t3uu7fsmJ9+ABdrCDUAUkfp84LWdKynt6vH568HwFf6Lk8wQfUTUC2EsuoHQMdI9S4n+/cvVUkCXeKnz/yi2n5ZFEHcv1QliZcn1vf32g+AnHuGer+EMtdiipx/vAYgJgJZ9gMIoN/DxYqQAVBePIAeUdvU0/POM1k9Ps88DBHqPYMviH4CfSq+Qz8Ep34AYj2+/rSK9Yqh9hJRv3fnFoqPnyHVtdOX9Sd9hH507QSpStLEBCjlF70mqniPa1Aqu7/XfgAk+dt673t8coro/MtmR5X6AVx4AAa7XHUFtmAInS6hMXs7o9c72t1RXiXlC2s65FCjc3SsyyhcEa1YDizkAgRi/1M3ZN4eJ+Lc+OxtaXdWURsQOwfTKj59ZhA9N123+PQZ5t7fY89Bef10DjAajFK5L6/WUxRA9f6b3zySdscVtQG+QaZJgkjqAsQOvrLOwez5W8mLKMB5dgJyBBvjjzX0Xj09r4az7/c0hsCKdmycgGxascdntA39+ZnvTip5AVdN1yGJnqokTfCMEXQ1Bsyar08E72a+vCwbkGcK2ewosF+0rAsgoreFv1ivJwOwMxXsJHqQRO+wOj3ibdqFGK0iBh074g9rvrteqZoI3grebqnc300/AHTTekkjECW/eC2//QAu1jlmABESuI0m0D/fnoaaCiZCp6vaE4NgGoOX2v1A5rsD9n3fQ5wvr9RXv9s3nyQ/T8xe+vJfrNeMAQzLsptvz4ff6HhJ70n8ku5/XLnfevxBw9vW8+879+kPoh/AxbpgAIEQv5XqH8Z8e74fABGim3r8QcOr1PM7teR2gr9YFwxg0CZCn4QPYr49T4R+5rsPGt5NX/0w4C/WBQMYBg1BScUWJa+f+e5RwgfVV98r/MW6YADnnikEPd89anhZX31ZHj99Dhr+Yl0wgHO7xOIf3sHGE5tok5N0HjS8WPzD2/U8sYo2PUl3v/BIXxQDDXL9/wAoZQX9VAu0ywAAAABJRU5ErkJggg==');
      background-position: 3em 0;
    }

      .tile-rock {
        background-position: 4em 0;
      }

      .tile-sky { /** really just a transparent tile **/
        background-image: none;
        background: none;
      }

    .edge {
      clear: both;
    }

    #world span {
      position: absolute;
      width: 1em;
      height: 1em;
    }

    .character {
      position: absolute;
      width: 1em;
      height: 1em;
      border-radius: 50%;
      text-align: center;

      -webkit-transition: all 0.1s linear;
         -moz-transition: all 0.1s linear;
           -o-transition: all 0.1s linear;
              transition: all 0.1s linear;

      
    }

    .sprite-character-default {

    }

      .character:before {
        display: inline-block;
        content: "";
        position: relative;

      }

      /**
       * I'm putting it in a before so that the size of the sprite doesn't influence the rendering
       */
      .sprite-character-default:before,
      .sprite-character-default-left:before,
      .sprite-character-default-right:before {
        width: 24px;
        height: 32px;
        background-image: url('data:image/png;base64,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');
        background-position: 0 160px;
        -webkit-transform: scale(1.4);
        
      }

        .sprite-character-default-left:before {
          background-position: 0 64px;
        -webkit-animation: hero-walk-left 1s steps(8) infinite reverse;
        }

          @-webkit-keyframes hero-walk-left {
            from { background-position: 0 64px; }
            to   { background-position: 192px 64px; }
          }

        .sprite-character-default-right:before {
          background-position: 0 160px;
        -webkit-animation: hero-walk-right 1s steps(8) infinite reverse;
        }

          @-webkit-keyframes hero-walk-right {
            from { background-position: 0 160px; }
            to   { background-position: 192px 160px; }
          }

      .sprite-monster-default:before,
      .sprite-monster-default-left:before,
      .sprite-monster-default-right:before {
        width: 54px;
        height: 72px;
        top: -25px;
        left: -12px;
        background-image: url('data:image/png;base64,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');
        background-position: 0 0;
        -webkit-transform: scale(0.9);
        
      }

        .sprite-monster-default-right:before {
          background-position: 0 216px;
          -webkit-animation: monster-walk-right 0.5s steps(3) infinite alternate;
        }

          @-webkit-keyframes monster-walk-right {
            from { background-position: 0 216px; }
            to   { background-position: 162px 216px; }
          }

        .sprite-monster-default-left:before {
          background-position: 0 72px;
          -webkit-animation: monster-walk-left 0.5s steps(3) infinite alternate;
        }

          @-webkit-keyframes monster-walk-left {
            from { background-position: 0 72px; }
            to   { background-position: 162px 72px; }
          }


    /**
     * CHARACTER COMPONENTS
     */
    .character-component {}

    .attack-sword {}

      .attack-sword:before {
        position: absolute;
        content: "";
        top: 0.63em;
        left: -0.1em;
        background: rgba(255, 255, 255, 0.5);
        border: 1px solid white;
        border-radius: 3px;
        width: 0.5em;
        height: 0.1em;
      }

      .sprite-character-default-left .attack-sword:before {
        left: -1.1em;
      }



    
  </style>
  <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
</head>

<body>
  <div id="world-container">
    <div id="world"></div>
  </div>
  <div id="debug">
    <h1>Debug</h1>
    <p>
      Arrows: movement<br />
      Space: jump<br />
      Z: attack
    </p>

    <button type="button" id="pause" data-state="playing">Pause</button>
    <script>
      $('#pause').click(function() {
        if($(this).data('state') == "playing") {
          console.log(game.stopLoop);
          game.stopLoop();
          $(this).data('state', 'paused');
          $(this).text('Play');
        } else {
          game.startLoop();
          $(this).data('state', 'playing');
          $(this).text('Pause');
        }
      });
    </script>

    <div id="fpsRate"></div>
  </div>

  <script>
  $(function() {

    (function() {

      /**
       *
       * okay here's the second test. It'll probably be the last one with all the code in the same page.
       * so I guess we'll make it more like an actual game this time. Say, we have a hero that
       * has to get 2 components from a map, gaining a new power everytime. (I've been playing Zelda.)
       * 
       */
      
      // just a helper function for handlign objects
      var count = function(obj) { return Object.keys(obj).length; }

      /*
       *
       * We prepare the animation frame for all browsers
       * I decided to switch to this to test performances
       */
      window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                function( callback ){
                  window.setTimeout(callback, 1000 / 60);
                };
      })();

      /**
       * We make a quick default map
       * @type {Array}
       */
      var defaultMap = (function() {
        var returnedMap = [];
        var groundHeight = 2;

        //create ground
        for (var x = 500; x >= 0; x--) {
          for(var y = Math.floor((Math.random()*2) + groundHeight); y >= 0; y--) {
            // for every every column, we add 5 blocks of rock
            // [ TOTALHEIGHT * TOTALWIDTH - CURRENT HEIGHT - CURRENT WIDTH ]
            returnedMap[ ((500 * 20) - (500 * y)) - (50 + x) ] = {
                physics: {
                  'stopCharacter': true
                },
                sprite: (Math.floor((Math.random()*50))) ? 'rock' : 'grass'
            };
          }
        }

        return returnedMap;
      })();

      
      

      var 
      /**
       * now this time, I'll make a game object that's more like a handler of the loop.
       */
      game = {
            /**
             * default options for the game
             */
            options : {
              fpsRate: 60,
              pixelScale: 32,
              map: defaultMap
            },

            /**
             * the jQuery element containing the world
             * @type {[type]}
             */
            $el : $('#world'),

            /**
             * contains the setTimeout id so we can clear it on command
             * @type {Boolean}
             */
            _loopId : false,

            _frameTime: 0,

            /**
             * whether to update to next frame
             * @type {Boolean}
             */
            _loopEnabled : false,

            _speedCounter: 0,


            /**
             * The game goes too quickly for my taste, so we'll tweak it with this
             * @type {Number}
             */
            // _gameSpeed: 20, // 100 = native speed

            /**
             * The main game loop
             */
            loop: function() {
              // I slowed down the engine because it was too fast :o
              // I'm not sure how to make anything else slow down yet
              if(game._loopEnabled && game._speedCounter >= 3) {
                  game._speedCounter = 0;
                  game.update((performance.now() - game._frameTime) * (game.options.fpsRate / 1000) );
              }

              game._speedCounter++;
              requestAnimFrame(game.loop);  
              game._frameTime = performance.now();
            },
            



            /**
             * The old loop that used setTimeout
             */
            // setTimeoutLoop : function() {
            //   this.update();

            //   if(this._loopEnabled) {
            //     this._loopId = setTimeout(function(g) {
            //       g.loop();
            //     }, this.options.fpsRate, this);
            //   }
            // },

            /**
             * the function that will start the chain of setTimeouts.
             * This is empty for now, but maybe there'll be some stuff we want to do when we load the loop
             * Like maybe check if the game's been initialized or something.
             */
            startLoop : function() {
              this._loopEnabled = true;
              this.loop();
            },

            /**
             * Again, this is empty, could be filled.
             */
            stopLoop : function() {
              this._loopEnabled = false;
              clearTimeout(this._loopId);
            },

            /**
             * Tell all objects to update
             */
            update : function(deltaTime) {
              this.module.map.update(deltaTime);
              this.module.objects.update(deltaTime);
              this.module.camera.update(deltaTime );
              this.module.debug.update(deltaTime);
            },

            /**
             * initialize the game
             */

            init: function() {
              this.module.input.init();
              this.module.map.init();
              this.module.camera.init();

              // we create a character
              var hero = game.module.characters.create({
                name: 'hero'
              }, [{
                name: 'gravity',
                component: Components.characterGravity
              }, {
                name: 'movement',
                component: Components.characterMovement
              }, {
                name: 'attack',
                component: Components.characterAttack
              }]);
              this.module.objects.add(hero);


              // we'll make some monsters too
              // position them randomly in the world
              for (var i = 50; i >= 0; i--) {
                var newMonster = game.module.characters.create({
                  name: 'monster' + i,
                  position: {
                    x: Math.floor(Math.random() * game.module.map.options.width),
                    y: Math.floor(Math.random() * game.module.map.options.height) - 5
                  },
                  sprite: 'monster-default',
                  sprites: {
                    'default': 'monster-default',
                    'movement-left': 'monster-default-left',
                    'movement-right': 'monster-default-right'
                  }
                }, [{
                  name: 'gravity',
                  component: Components.characterGravity
                }, {
                  name: 'movement',
                  component: Components.characterRandomMovement
                }]);

                this.module.objects.add(newMonster);
              };

              this.startLoop(); 



            }


      };

      /**
       * to make it more modular and clean, we make a new class/namespace for handling objects.
       */
      game.module = {};

      /**
       * So we'll make a list of all possible input actions, and then we'll make event handlers to turn
       * them on and off.
       * @type {Object}
       */
      game.module.input = {
        /**
         * A list of all the input events
         * @type {Object}
         */
        _inputs : {
          CAMERA_LEFT: false,
          CAMERA_RIGHT: false,
          PLAYER_LEFT: false,
          PLAYER_RIGHT: false,
          PLAYER_JUMP: false,
          PLAYER_ATTACK: false
        },

        init: function() {
          var inputModule = this;

          $('body').keydown(function(e) {
            switch(e.keyCode) {
              case 38: // UP ARROW
                inputModule._inputs.CAMERA_LEFT = e;
                break;

              case 40: // DOWN ARROW
                inputModule._inputs.CAMERA_RIGHT = e;
                break;

              case 37: // LEFT ARROW
                inputModule._inputs.PLAYER_LEFT = e;
                break;

              case 39: // RIGHT ARROW
                inputModule._inputs.PLAYER_RIGHT = e;
                break;

              case 32: // SPACE
                inputModule._inputs.PLAYER_JUMP = e;
                break;

              case 90: // Z
                inputModule._inputs.PLAYER_ATTACK = e;
                break;

              default:
                // console.log('key pressed: ', e.keyCode);
            }
          });

          $('body').keyup(function(e) {
            switch(e.keyCode) {
              case 38: // UP ARROW
                inputModule._inputs.CAMERA_LEFT = false;
                break;

              case 40: // DOWN ARROW
                inputModule._inputs.CAMERA_RIGHT = false;
                break;

              case 37: // LEFT ARROW
                inputModule._inputs.PLAYER_LEFT = false;
                break;

              case 39: // RIGHT ARROW
                inputModule._inputs.PLAYER_RIGHT = false;
                break;

              case 32: // SPACE
                inputModule._inputs.PLAYER_JUMP = false;
                break;

              case 90: // Z
                inputModule._inputs.PLAYER_ATTACK = false;
                break;

              default:
                console.log(e.keyCode);
            }
          });
        },

        isPressed: function(actionName) {
          return this._inputs[actionName];
        }

        


      },

      game.module.objects = {

        /**
         * contains a list of layers.
         * Every layer will contain an array of objects
         * objects in the 'static' layer will never be updated
         * This could even be its own class eventually, allowing to set specific interactivity
         * between layers
         * @type {Object}
         */
        layers: {},

        /**
         * I figured I'd use a very basic layer implementation
         * @param {[type]} layer [description]
         */
        addLayer: function(layer, zIndex) {
          if(!(this.layers[layer] instanceof Array)) {
            if(!zIndex) {
              // so crude!
              zIndex = count(this.layers) + 5;
            }

            this.layers[layer] = [];

            var $layer = '<div class="layer" id="layer-' + layer + '" z-index="' + zIndex + '"></div>';
            game.$el.append($layer);
          }
        },

        /**
         * We add the object to the layer, and then to the DOM if the object has an element
         * @param {Object} object
         * @param {String} layer
         */
        add : function(newObject) {
          
          if(newObject.layer) {
            if(!(this.layers[newObject.layer] instanceof Array)) {
              this.addLayer(newObject.layer);
            }

            // warn the user if the object already exists
            if(typeof this.layers[newObject.layer][newObject.name] === 'object') {
              console.warn('There is already an object with name: ' + newObject.name);
            }

            // save the object in the layer
            this.layers[newObject.layer][newObject.name] = newObject;

            // output to DOM
            if(newObject.$el) {
              if(!game.$el.find('#layer-' + newObject.layer).length) {
                this.addLayer(newObject.layer);
              }

              game.$el.find('#layer-' + newObject.layer).append(newObject.$el);  
            }
          }
        },

        /**
         * removes the object from the DOM and from layers
         * @param  {String} objectName
         * @param  {String} layers
         */
        remove : function(objectName, layer) {
            // remove from DOM
            if(typeof this.layers[layer][objectName].$el === 'object') {
              this.layers[layer][objectName].$el.remove();
            }

            // remove from layers
            if(typeof this.layers[layer][object.name].remove === 'function') {
              this.layers[layer][object.name].remove();
            } else {
              this.layers[layer][object.name] = null;
            }
        },

        each: function(fn, layer) {
          if(layer) { return this.layers[layer]; }

          for(var l in this.layers) {
            if(l != "static" && this.layers.hasOwnProperty(l)) {
              var layer = this.layers[l];

              // loop over objects in the layer
              for(var o in layer) {
                if(layer.hasOwnProperty(o)) {
                  var obj = layer[o];

                  // update if the object has such a function.
                  if(typeof obj.update === 'function') {
                    obj.update();
                  }
                }
              }
            }
          }


        },

        /**
         * All layers will update their objects except for the static layer
         */
        update : function(deltaTime) {
          // loop over layers
          for(var l in this.layers) {
            if(l != "static" && this.layers.hasOwnProperty(l)) {
              var layer = this.layers[l];

              // loop over objects in the layer
              for(var o in layer) {
                if(layer.hasOwnProperty(o)) {
                  var obj = layer[o];

                  // update if the object has such a function.
                  if(typeof obj.update === 'function') {
                    obj.update(deltaTime);
                  }
                }
              }
            }
          }
        }
      }


      /**
       * handler for the map. This will put the tiles on the game and handle moving the game view
       * along the map of the game. So what I'll do is have a map of all the objects in the world,
       * with a default tile for when there are no objects. I won't do the border of terrains, even
       * though I have the sprites for them, it's just a lot of nitpicky stuff. Maybe on the next engine.
       */
      game.module.map = {

        options : {
          // we'll basically make it into a side scroller by doing this.

          width: 500,
          height: 20
        },

        /**
         * contains a list of all the map tiles in the world, not only those contained on the screen
         * We'll actually fill this up with only the items of interest. We'll make a default tiles for
         * the other ones. Less stuff to process that way.
         * A way to extend this map is to have layers and make parallax effects. It should not be
         * too hard actually. I might end up doing this.
         * @type {Array}
         */
        _map : game.options.map || [],

        /**
         * Some fake tiles to use for 'hard' tiles
         * @type {Object}
         */
        _systemTiles: {
          NO_LEVEL: {
            'type': 'NO_LEVEL',
            physics: {
              'stopCharacter': true
            }
          }
        },


        /**
         * get the tile object from the map at this
         * @param  {[type]} x
         * @param  {[type]} y
         * @return {[type]}
         */
        getTile: function(position) {
          return this._map[(game.module.map.options.width * position.y) + position.x];
        },

        getSurroundingTiles: function(position) {
          return {
            up:   position.y - 1 <= 0 ? this._systemTiles.NO_LEVEL : this._map[(game.module.map.options.width * (position.y - 1)) + position.x],
            down: position.y + 1 >= game.module.map.options.height ? this._systemTiles.NO_LEVEL : this._map[(game.module.map.options.width * (position.y + 1)) + position.x],
            left: position.x - 1 <= 0 ? this._systemTiles.NO_LEVEL : this._map[(game.module.map.options.width * (position.y)) + position.x - 1],
            right: position.x + 1 >= game.module.map.options.width ? this._systemTiles.NO_LEVEL : this._map[(game.module.map.options.width * (position.y)) + position.x + 1]
          };
        },

        /**
         * I originally put the camera in the map, but then realized that it's
         * easier to have the camera update the position of all the objects in the scene.
         * @return {[type]}
         */
        update: function(deltaTime) {
        },

        /**
         * We initialize the map
         * @return {[type]}
         */
        init: function() {
        }


      };

      /**
       * contains the view of the map.
       * We could actually dynamically switch maps and keep our camera and players intact. We might
       * want to place the camera again. but if there are any effects on them, it works pretty well!
       * @type {Object}
       */
      game.module.camera = {

        _tiles : [],

        _defaultTile: 'sky',
        
        /**
         * by adding padding, it could allow me to move or shake the camera.
         * @type {Number}
         */
        padding : 5,

        /**
         * view width
         * @type {Number}
         */
        width  : 30,

        /**
         * view height
         * @type {Number}
         */
        height : 20,

        /**
         * the current position relative to the map
         * @type {Object}
         */
        position: {
          // side-scroller, no need for y axis
          // but we'll start it in the middle to be Metroidy.
          x: game.module.map.options.width / 2 
        },

        cameraToMapCoordinates: function(position) {
          //console.log(position.x);
          return {
            x: this.position.x + position.x,
            y: position.y
          };
        },

        mapToCameraCoordinates: function(position) {
          return {
            x: position.x - this.position.x,
            y: position.y
          };
        },

        /**
         * tell tiles how to be styled according to the map
         * @return {[type]}
         */
        update: function(deltaTime) {
          this.processInputs(deltaTime);
          this.updateTiles(deltaTime);
          this.updateObjects(deltaTime);
        },

        processInputs: function(deltaTime) {
          // if(game.module.input.isPressed('CAMERA_LEFT')) {
          //   // move the camera left
          //   game.module.camera.move(-1);
          // } else if(game.module.input.isPressed('CAMERA_RIGHT')) {
          //   if(this.position.x != game.module.map.options.width - this.width) {
          //     this.position.x++;
          //   }
          // }
        },

        move: function(distance) {
          var newPos = this.position.x + distance;
          if( newPos >= 0 && newPos <= game.module.map.options.width - this.width ) { 
            this.position.x = newPos;
          }
        },

        updateObjects: function(deltaTime) {
          // loop over layers
          for(var l in game.module.objects.layers) {
            if(l != "static" && game.module.objects.layers.hasOwnProperty(l)) {
              var layer = game.module.objects.layers[l];

              // loop over objects in the layer
              for(var o in layer) {
                if(layer.hasOwnProperty(o)) {
                  var obj = layer[o];

                  // place the object in css according to its position
                  if(obj.hasOwnProperty('position') && obj.$el.length) {
                    objCameraPosition = this.mapToCameraCoordinates(obj.position);

                    // we only replace it if it's within the view of the screen
                    if(
                      objCameraPosition.x > 0 && objCameraPosition.x < game.module.camera.width &&
                      objCameraPosition.y > 0 && objCameraPosition.y < game.module.camera.height
                    ) {
                      obj.$el.css('display', 'block');
                      obj.$el.css('left', objCameraPosition.x + 'em');
                      obj.$el.css('top', objCameraPosition.y + 'em');
                    } else {
                      obj.$el.css('display', 'none');
                    }
                  }
                }
              }
            }
          }
        },

        /**
         * switches sprites rendering on an object
         * 
         * @param  {Object} obj       The object to be changed
         * @param  {String} newSprite The name of the sprite
         */
        changeSprite: function(obj, newSprite) {
          var oldSprite = obj.$el.data('sprite');
          if(oldSprite != obj.sprites[newSprite]) {
            obj.$el.removeClass('sprite-' + oldSprite);
            obj.$el.addClass('sprite-' + obj.sprites[newSprite]);
            obj.$el.data('sprite', obj.sprites[newSprite]);
          }
        },

        updateTiles: function(deltaTime) {

          var mapSize = this.width * this.height;

          for(var i = 0; i < mapSize; i++) {

            var
              x           = i % this.width,
              y           = Math.floor(i / this.width),
              coordsOnMap = this.cameraToMapCoordinates({x: x, y: y}),
              tileObj     = game.module.map.getTile(coordsOnMap),
              tileClass   = (tileObj && tileObj.sprite) ? tileObj.sprite : this._defaultTile,
              oldSprite   = this._tiles[i].data('sprite');

            if(oldSprite != tileClass) {
              this._tiles[i].removeClass('tile-' + oldSprite);
              this._tiles[i].addClass('tile-' + tileClass);
              this._tiles[i].data('sprite', tileClass);
            }
          }

        },

        /**
         * 
         */
        init: function() {
          // we set the scale of the world
          // passing from javascript to css by using the body's em value
          game.$el.css('font-size', game.options.pixelScale + 'px');

          // we create the world tiles

          var $map = $('#map');

          if(!$map.length) {
            $map = $('<div id="map"></div>');
          }

          var mapSize = this.width * this.height;
          for(var i = 0; i < mapSize; i++) {
            var x = i % this.width;
            var y = Math.floor(i / this.width);

            //console.log(x, y);
            
            // create a div for every tile
            var coordsOnMap = this.cameraToMapCoordinates({x: x, y: y});
            var tileObj = game.module.map.getTile(coordsOnMap);

            var tileClass = (tileObj && tileObj.sprite) ? tileObj.sprite : this._defaultTile;
            

            this._tiles[i] = $('<div class="tile tile-'+ tileClass +'"></div>');
            this._tiles[i].data('sprite', tileClass);
            this._tiles[i].css('left', x + 'em');
            this._tiles[i].css('top', y + 'em');
 
            // break line at every WIDTH
            if((i % this.width) == 0) {
              this._tiles[i].addClass('edge');
            }

            // add the tile to the map
            $map.append(this._tiles[i]);
          }

          // add the map to the world
          game.$el.append($map);

        }

      };

      /**
       * I made this after the characters module but put it over it because the characters module is longer 
       * and this is more self-contained
       * @type {Object}
       */
      game.module.collider = {
        name: 'Collider Module',

        /**
         * An array to hold all of this frame's collisions.
         * I'm not sure if this is actually useful, but will comment it out if it's not used
         * @type {Array}
         */
        _collisions: [],

        init: function() {
            // nothing to do
        },

        /**
         * a collider will go through all the world's objects and check for collisions
         * if the object has a collide method, we call it.
         * @return {[type]} [description]
         */
        update: function(deltaTime) {

        }

      };

      /**
       * so in the character module, we put a character generator and other character handlers.
       * a character will have components to give it certain behaviours.
       */
      game.module.characters = {
        name: 'Character Module',

        _characters : {},

        /**
         * changes an object's sprite.
         * 
         * I put this function here because having a character call the camera was weird
         * But having the module that takes care of all characters makes sure that all characters
         * are rendered properly, and telling the camera that the object changed sprite seems to
         * make sense to me.
         * 
         * @param  {[type]} obj       [description]
         * @param  {[type]} newSprite [description]
         * @return {[type]}           [description]
         */
        changeSprite: function(obj, newSprite) {
          // tell camera
          game.module.camera.changeSprite(obj, newSprite);
        },

        create: function( options, addedComponents ) {
          // maybe I will just check if any object in game.module.objects exists
          if(options && this._characters.hasOwnProperty(options.name)) {
            console.error('ComponentEngine [module.characters]: The character name "' + options.name +'" already exists');
            return false;
          }

          var defaultCharacter = {
            
            /**
             * We create a default non-repeating name
             * @type {String}
             */
            name: 'EmptyCharacter' + Object.keys(this._characters).length,

            /**
             * current sprite
             * @type {String}
             */
            sprite: 'character-default',

            /**
             * object of possible sprites
             */
            sprites: {
              'default': 'character-default'
            },


            $el: $('<div class="character"></div>'),

            surroundingTiles: null,

            facing: 1, // right: 1, left: -1

            speed: 0.7,

            /**
             * we make a copy of component
             * (essentially a "new game.module.component()" if had made it into a generator)
             * I'm just trying this pattern instead to compare its effects
             * @type {Object}
             */
            component: $.extend(true, {}, game.module.componentManager),

            /**
             * I wasn't sure whether to use the map position or the camera position for this.
             * I ended up using the map position after I realized that the camera should be its own module
             * when I had originally put it inside of the map for it to only render the map.
             * my camera really becomes a full fledged renderer, I suppose.
             * @type {Object}
             */
            position: {
              x: game.module.map.options.width / 2 + game.module.camera.width / 2,
              y: game.module.map.options.height / 2
            },

            /**
             * @type {String}
             */
            layer: 'character',

            update: function(deltaTime) {
              this.component.update(deltaTime, this);
            },

            collide: function() {
              this.component.each(function(component) {
                console.log('colling with', this, component);
              });
            },

            /**
             * I prefer to have move() for relative movement and moveTo() for absolute movement within the map
             * @param  {Object} translation object with x and y as properties
             */
            move: function(translation) {
              
              if(this.position.x + translation.x < 0 ) { this.position.x = 0; return; }
              if(this.position.y + translation.y < 0 ) { this.position.y = 0; return; }
              if(this.position.x + translation.x > game.module.map.width ) { this.position.x = game.module.map.width; return; }
              if(this.position.y + translation.y > game.module.map.height ) { this.position.y = game.module.map.height; return; }

              this.position.x += translation.x;
              this.position.y += translation.y;
            },

            moveTo: function(position) {
              if(position.x < 0 ) { this.position.x = 0; return; }
              if(position.y < 0 ) { this.position.y = 0; return; }
              if(position.x > game.module.map.width ) { this.position.x = game.module.map.width; return; }
              if(position.y > game.module.map.height ) { this.position.y = game.module.map.height; return; }

              this.position.x = position.x;
              this.position.y = position.y;
            },

            toLayer: function(layer) {

            }
          };

          // we replace any defaults with the options
          newCharacter = $.extend(defaultCharacter, options);

          for(var c in addedComponents ) {
            var newComponent = addedComponents[c];

            newCharacter.component.add(newComponent.component(newComponent.name)); // hah, that's not confusing at all
          }
          // newCharacter.component.add(Components.characterMovement('movement'));
          // newCharacter.component.add(Components.characterAttack('attack'));
          newCharacter.component.init(newCharacter);
          
          // we put in the right sprite on init
          newCharacter.$el.addClass('sprite-' + newCharacter.sprite).data('sprite', newCharacter.sprite);

          // add to list of characters
          this._characters[newCharacter.name] = newCharacter;
          
          return newCharacter;
        }
      };

      /**
       * We make a component manager so that we can carry that behaviour around
       * I could have done this directly in the character module, but this seems
       * like a good idea so I can be more granular and modular at the same time
       * @type {Object}
       */
      game.module.componentManager = {
        
        /**
         * contains the manager's components
         * @type {Object}
         */
        _components : {},

        /**
         * contains the parent object
         */
        parent: null,

        add: function(component) {
          if(this._components.hasOwnProperty(component.name)) {
            console.error('ComponentEngine [' , this , ' ]: this object already has a component named ' + component.name)
            return;
          }
          this._components[component.name] = component;
        },

        set: function(component) {
          this._components[component.name] = component;
        },

        remove: function(name) {
          delete this._components[name];
        },

        get: function(name) {
          return this._components[name];
        },

        update: function(deltaTime) {
          // we update every component
          this.parent.surroundingTiles = game.module.map.getSurroundingTiles({
              x: this.parent.position.x,
              y: this.parent.position.y
          });
          this.each(function(c) { c.update(deltaTime, this.parent); })
        },

        init: function(character) {
          this.parent = character;
           // we init every component
          this.each(function(c) { c.init(this.parent); });
        },

        each: function(fn) {
          if(typeof fn === "function") {
            for(var component in this._components) {
              fn.apply(this, [this._components[component]]);
            }
          }
        }

      };

      /**
       * we make individual modules
       */
      var Components = {};

      /**
       * We'll start simple and make a component for basic movement
       * @type {Object}
       */
      Components.characterMovement = function(name) {

        // I went back to doing a return, just because it looks
        // less threatening than a deep copy
        return {
          name: name,

          init: function(character) {
            var movementSprites = {};

            movementSprites[name + '-left']  = 'character-default-left';
            movementSprites[name + '-right'] = 'character-default-right';

            // we don't let the init write over sprites defined by the character
            // so we switch the usual extend order
            character.sprites = $.extend(movementSprites, character.sprites);
          },

          update: function(deltaTime, character) {
            var surroundingTiles = character.surroundingTiles;

            // player movement
            if(game.module.input.isPressed('PLAYER_LEFT') && (typeof surroundingTiles.left === 'undefined' || !surroundingTiles.left.physics.stopCharacter)) {
              game.module.camera.move(-1);
              console.log(-1);
              character.move({x: -1, y: 0});
              character.facing = -1;
              game.module.characters.changeSprite(character, name + '-left');
            } else {
              // character.$el.removeClass('left');
            }
            if(game.module.input.isPressed('PLAYER_RIGHT') && (typeof surroundingTiles.right === 'undefined' || !surroundingTiles.right.physics.stopCharacter)) {
              game.module.camera.move(1);
              character.move({x: 1, y: 0});
              character.facing = 1;
              game.module.characters.changeSprite(character, name + '-right');
              // character.$el.addClass('right');
            } else {
              // character.$el.removeClass('right');
            }
            if(game.module.input.isPressed('PLAYER_JUMP')
              && (typeof surroundingTiles.up === 'undefined' || !surroundingTiles.up.physics.stopCharacter)
              && (typeof surroundingTiles.down !== 'undefined' && surroundingTiles.down.physics.stopCharacter)
              && !this.jumping
              ) {
              this.jumping = true;
              character.move({x: 0, y: -5});
            } else if(!game.module.input.isPressed('PLAYER_JUMP') && this.jumping && typeof surroundingTiles.down !== 'undefined' && surroundingTiles.down.physics.stopCharacter) {
              this.jumping = false;
            }

          }
        };
        
      };

      /**
       * We make an attack handler
       * @type {Object}
       */
      Components.characterAttack = function(name) {

        return {
          name: name,

          _isAttacking: false,

          init: function(character) {
            // we can do things here like set which action is used for it (like PLAYER_ATTACK)
          },

          update: function(deltaTime, character) {
            var isAttacking = this._isAttacking;

            if(game.module.input.isPressed('PLAYER_ATTACK') && !isAttacking) {
              this._isAttacking = true;
              // do some Attacking

              // we should probably check the character's weapon and render that
              // rather than create a weapon outright here
              if(!$('#sword').length) {
                $('<span class="attack-sword character-component" id="sword"></span>')
                  .appendTo(character.$el);
              }

            } else if(!game.module.input.isPressed('PLAYER_ATTACK') && isAttacking) {
              this._isAttacking = false;
              $('#sword').remove();
            }

          },

          collide: function(character, collider) {
            console.log(character, 'collided with', collider);
          }
        };
        
      };

      /**
       * We make a simple gravity component for all our monsters/heroes
       * @type {Object}
       */
      Components.characterGravity = function(name) {

        return {
          name: name,

          init: function(character) {
            // we can do things here like set which action is used for it (like PLAYER_ATTACK)
          },

          update: function(deltaTime, character) {
            // crude gravity
            if(typeof character.surroundingTiles.down === 'undefined' || !character.surroundingTiles.down.physics.stopCharacter) {
              character.move({x: 0, y: 1});
            }

          }
        };
        
      };


      /**
       * We'll start simple and make a component for basic movement
       * @type {Object}
       */
      Components.characterRandomMovement = function(name) {

        return {
          name: name,

          // I try to check if the character is stuck and then move it if need be
          _stuckCounter: 0,

          init: function(character) {
            var movementSprites = {};

            movementSprites[name + '-left']  = name + '-left';
            movementSprites[name + '-right'] = name + '-right';

            character.facing = Math.floor(Math.random()*2) == 1 ? 1 : -1;

            // we don't let the init write over sprites defined by the character
            // so we switch the usual extend order
            character.sprites = $.extend(movementSprites, character.sprites);
          },

          update: function(deltaTime, character) {
            var surroundingTiles = character.surroundingTiles;
            var userCanGo = [];

            if(this._stuckCounter >= 3) {
              character.move({x: 0, y: -5});
              character.facing = Math.floor(Math.random()*2) == 1 ? 1 : -1;
              this._stuckCounter = 0;
              return;
            }

            if(typeof surroundingTiles.left === 'undefined' || !surroundingTiles.left.physics.stopCharacter) {
              userCanGo.push(-1); // userCanGo[0] = left
            }
            if(typeof surroundingTiles.right === 'undefined' || !surroundingTiles.right.physics.stopCharacter) {
              userCanGo.push(1); // userCanGo[0 or 1] = right
            }
            if(!userCanGo.length) {
              character.move({x: 0, y: -5});
              this._stuckCounter++;
              return;
            }

            // hits a wall
            if(userCanGo.length == 1) {
              this._stuckCounter++;
              
              character.move({x: userCanGo[0], y: 0});
              character.facing = userCanGo[0];
              game.module.characters.changeSprite(character, name + '-' + (userCanGo[0] > 0 ? 'right' : 'left' ));
              return;
            }

            if(Math.floor(Math.random() * 10) > 8 && (typeof surroundingTiles.down !== 'undefined' && surroundingTiles.down.physics.stopCharacter)) {
              character.move({x: 0, y: -5});
            }

            // go in the direction he's already facing
            character.move({x: character.facing, y: 0});
            if(this._stuckCounter > 0) this._stuckCounter--;
          }
        };        
      };










      /**
         * GAME DEBUG
         */
        game.module.debug = {
          name: 'Debug Module',

          _framesFps: [],

          init: function() {

          },

          update: function(deltaTime) {
                        
            if(this._framesFps.length > 60) {
              this._framesFps.shift();
            }
            this._framesFps.push( 60 * deltaTime );

            $('#fpsRate').text( Math.floor(this._framesFps.reduce(function(pv, cv) { return pv + cv; }, 0) / this._framesFps.length * 10)/10 + ' FPS');
          }
        }

      game.init();
      window.game = game;
    })();
  });
  </script>
</body>
</html>